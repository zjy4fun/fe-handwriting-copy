<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>微任务和宏任务</title>
</head>
<body>
<!--
    宏任务: setInterval(), setTimeout()
    微任务: new Promise(), new MutationObserver()
    当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件, 然后再去宏任务队列中取出一个事件
    同一个事件循环中, 微任务永远在宏任务之前执行

    **宏任务(macrotask)和微任务(microtask)**
    当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。

    Macrotasks包含生成dom对象、解析HTML、执行主线程js代码、更改当前URL还有其他的一些事件如页面加载、输入、网络事件和定时器事件。
    从浏览器的角度来看，macrotask代表一些离散的独立的工作。当执行完一个task后，浏览器可以继续其他的工作如页面重渲染和垃圾回收。

    Microtasks则是完成一些更新应用程序状态的较小任务，如处理promise的回调和DOM的修改，这些任务在浏览器重渲染前执行。
    Microtask应该以异步的方式尽快执行，其开销比执行一个新的macrotask要小。
    Microtasks使得我们可以在UI重渲染之前执行某些任务，从而避免了不必要的UI渲染，这些渲染可能导致显示的应用程序状态不一致。
    -->
<script>
    //宏任务
    setTimeout(function () {
        console.log(1)
    })

    //微任务
    new Promise(function (resolve, reject) {
        console.log(2)
        resolve(3)
    }).then(function (val) { //.then里面的才是微任务
        console.log(val)
    })
    //2 3 1
</script>
</body>
</html>